# 标尺在编辑器中的位置

在这个项目中，我不仅仅在实现了标尺的基本功能，而且一直在思考：

1. 编辑器需要标尺的哪些功能
2. 编辑器需要实现哪些功能和标尺配合
3. 标尺在整个编辑器中的位置（功能的界定）
4. 标尺的延伸，编辑器的分层

## 1 标尺的基本功能

在一个页面编辑器中，标尺（`Ruler + Guides`）是很常见的一种功能。通过 Canvas 在页面上绘制两把尺子（`Ruler`），配合由尺子拖出来的无数参考线（`Guides`），用户可以很方便的进行元素定位，那么我们可以通过 PS 、Sketch 和 Figma 这些工具的使用，去体验出标尺组件的基本功能：

1. `Ruler` 提供精确到 px 的刻度线，并且需要考虑缩放率（`scale`）及设备分辨率（`ratio`），保证绘制的准确性
2. `Ruler` 起点 0 刻度是组件容器的左上角
3. `Ruler` 需要在尺子上根据激活元素着色
4. `Ruler` 在鼠标 hover 的时候，需要显示一条参考线（`PseudoLine`）
5. `Ruler` 上点击的时候，创建一条 `Guide`
6. `Guide` 移到 `Ruler` 区域的时候，松开鼠标自动删除
7. `Guide` 只有在 `Ruler` 区域才可以自由拖动
8. `Guide` 的功能按钮可配置
9. `Ruler` 的样式可配置

以上就是一个标尺组件需要做到的基本功能

## 2 标尺功能配合

单一的标尺功能并不能提供用户很大的方便，标尺组件需要和编辑器中的其他元素（或者说其他层）进行联动，主要体现在对渲染层，也就是画布本身的缩放（`scale`）、滚动（`wheel`）以及画布中组件的位置（`position`）、拖拽（`drag`）、变形（`resize`）进行监听。除了 `scale` 是进行计算之后重绘标尺组件，其他都是对画布中的组件进行监听，当进行拖动、滚动等操作的时候，触发标尺组件的更新。

我们也可以对渲染层与标尺层进行进一步的解耦，渲染层上操作触发的数据变动会改变数据管道中的状态，标尺组件对数据变动做出反应，这是很清晰的 `UI = F(S)`

除了标尺监听渲染层的变化之外，渲染层上的拖拽操作也需要考虑标尺组件中的 `Guides`，编辑器中所有的类参考线，都需要搭配**数值显示**（`Guide` 的数值由 `Ruler` 提供）与**组件吸附**（与外层联动）功能。 

## 3 标尺在编辑器中的位置

借用云凤蝶的分层概念：

![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gip7lcvm7tj30pm0cm3zi.jpg)

在添加了这么多交互层之后，留给用户的操作空间很少，所以标尺组件不能占用画布上的操作空间，也就是在画布中，不能被选中拖动，这也是我为什么特地花时间去实现只有在 `Ruler` 上才能拖动 `Guides` 的功能的原因。

拖拽应该还是使用 `MouseEvent` 的方式去实现（经典好用）

## 4 延伸思考

### 4.1 标尺组件是否要拆分

我在这个项目中看到拆开来的例子：https://github.com/daybrush/scena

它将标尺组件拆分为 `Ruler` 和 `Guides` 两个组件，但是有趣的是，它在画布中组合使用两者的时候，写了很多代码去保证两者的数据通信，这和我一开始的做法是一样的，不过我是在一个组件内组隔离这两个组件。

但是通过后续的开发，我觉得拆分没有必要：

1. 这两个组件没有复用的场景，而多余功能的禁用可以通过完备的配置选项去实现
2. `Ruler` 和 `Guides` 都需要 `horizon` 属性去确定样式
3. 为保证标尺基本功能的实现，`Guides` 需要作为容器包裹 `Guides`，

最终我还是决定不拆分标尺，将 `Ruler` 和 `Guides` 作为编辑器的标尺层接入

### 4.2 编辑器分层

标尺组件只是编辑器重构的前期部分，走通了这样一个分层 + 数据管道的流程，下面的交互层也会很好实现：

1. 参考线层：一个组件有六条参考线（vt、vc、vb、hl、hc、hr）而用户每次只会操作（`drag`、`resize`）一个组件，那么这一层只需要存在六条线即可，然后通过渲染层组件间的关系，使用 `transform` 改变这六条线的状态（做得完备一点可以加入虚线的情况）
2. 间距线层：和参考线层一样，这一层只需要存在四条线，而且有些情况下只要显示一条
3. 框选：没想好
4. 右键菜单：没想好